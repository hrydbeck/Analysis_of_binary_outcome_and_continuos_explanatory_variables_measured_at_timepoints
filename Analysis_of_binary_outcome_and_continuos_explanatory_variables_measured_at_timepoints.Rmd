---
title: "Analysis of binary outcome and continuos explanatory variables measured at timepoints"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
author: "Halfdan Rydbeck"
date: "1/8/2020"
output:
  html_document:
    toc: true
  pdf_document:
    keep_tex: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**About this report**
This report was generated by using R markup notebook. R markup notebook  allows for writing code together with explanatory text in one script file. The script file can then be converted to an html or pdf document presenting the code, explanatory text and output in an esay to read, formatted report. This analysis was performed in R. Another alternative would have been to perform it using Python. When time is of essence, as it was in this case, I currently prefer to analyze with R. The package tidyverse provides tools for typicla datascience tasks and for plotting. is used readxl. The packages survival is uesd for .... The package survminer is used for .....

#```{r setup, include=FALSE}
## Searched for "tidyverse pdf r markdown" (https://chrisbeeley.net/?p=1037)
#knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_chunk$set(echo = TRUE, message = FALSE)
#```
Loading libraries
```{r Loading_libraries}
library("tidyverse")
#library("readxl")
#http://www.sthda.com/english/wiki/cox-proportional-hazards-model
#install.packages(c("survival", "survminer"))
library("survival")
library("survminer")
#install.packages(c("naniar"))
library(naniar)
```
Reading in file
```{r Reading in file}
d <- read_delim("/Users/halfdanr/Desktop/bioinf_gu/data/sample_file_dot_as_decimal_time_point_num.csv", delim=";")
```
# General description (explorative analysis) of the data
Look at some descriptive statistics and remove missing values

## Initial remarks
1. The data has been collected at 8 time points, a-h
2. The activity of 17 different cytokines have been measured at each time point, with some exception of missing data.
3. The activity of 5 different growth factors have been measured at all time points except time point a, with some exception of missing data.
4. In total the data encompasses 22 continuos explanatory time dependant variables, an one 1 binary time independent variable, sex, and one binary outcome variable. 
5. The distributions of cytokine measurements tend to include negative values. Could this be some calibration error?
6. The values of many the cytokine measurements tend to be overrepresented/clustering at the minimum of the distribution. Could this be measurement errors? Should these be removed? Plots of C3 with and without the most frequent value are shown below. Seems to take specific values almost look categorical. Take a look at Figure \ref{fig:fig1}
7. The range of the distributions for the continuous variables varies a lot. This can be seen form the output of the summary command
8. The precision of the measurement vary. G1 is for instance given with no decimals. Maybe it could be considered as categorical?

Plotting histogram of C3
```{r fig1, echo=FALSE, fig.cap="Plotting histogram of C3"}
par(mfrow=c(2,1))
ggplot(data = d) +
geom_histogram(mapping = aes(x = C3), binwidth = 0.05)
```
Removing most common value
```{r Removing most common value}
options(digits=15)
val_to_repl <- as.numeric(names(head(sort(table(d$C3),decreasing=TRUE),1)))
d_temp <- d
d_temp <- d_temp %>% replace_with_na(replace = list(C3 = val_to_repl))
```
Plotting histogram of C3 with most common value removed
```{r fig2, echo=FALSE, fig.cap="Plotting histogram of C3 with most common value removed"}
ggplot(data = d_temp) +
geom_histogram(mapping = aes(x = C3), binwidth = 0.05) 
```
A summary of the distribution of the variables
```{r A summary of the distribution of the variables}
summary(d)
```


Omitting missing values
```{r Omitting missing values}
d <- na.omit(d)
#summary(d)
```
### Some reflections
1. There are alternatve ways to deal with missing values. Rows with missing values can either be removed, as done wiht na.omit() in this case and automatically by most fuctions, or one can use methods for imputing those missing values like replacing with sample average.

## Plots of variation/distributions of variables
### "Gather" data
Here the format of the data frame is first changed from wide to long in ordeer to use the "facets" function of the tidyverse package. Cytokines and growth factors are "gathered" into two variables (making the data "longer")
```{r Gather}
d_long <- gather(d, "ck", "ck_value",c(C1:C17))
#G1 cannot be included since missing data
d_long <- gather(d_long, "gf", "gf_value",c(G1:G5))
```
### All data included
Plot the distrubution of the measurements of cytokines (C1-C17) and of growth factors. It can be seen that one specific low value is over represented.
```{r fig3, echo=FALSE, fig.cap="All data included ck"}#r All data included ck
ggplot(data = d_long) +
  geom_histogram(mapping = aes(x = ck_value),binwidth = 0.05) +
  facet_wrap( ~ ck)
```
Plot the distrubution of the measurements of growth factors
```{r fig4, echo=FALSE, fig.cap="Histograms of growth facors. All data included gf" }
#Histograms of growth facors
ggplot(data = d_long) +
  geom_histogram(mapping = aes(x = gf_value),binwidth = 100) +
  facet_wrap( ~ gf)
```

### Removing most common value from cytokine and growth factor variables
```{r Removing most common value from cytokine data}
d_test <- d
d_test <- na.omit(d_test)
#C1
val_to_repl <- as.numeric(names(head(sort(table(d$C1),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C1 = val_to_repl))
#C2
val_to_repl <- as.numeric(names(head(sort(table(d$C2),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C2 = val_to_repl))
#C3
val_to_repl <- as.numeric(names(head(sort(table(d$C3),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C3 = val_to_repl))
#C4
val_to_repl <- as.numeric(names(head(sort(table(d$C4),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C4 = val_to_repl))
#C5
val_to_repl <- as.numeric(names(head(sort(table(d$C5),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C5 = val_to_repl))


#C6
val_to_repl <- as.numeric(names(head(sort(table(d$C6),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C6 = val_to_repl))
#C7
val_to_repl <- as.numeric(names(head(sort(table(d$C7),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C7 = val_to_repl))
#C8
val_to_repl <- as.numeric(names(head(sort(table(d$C8),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C8 = val_to_repl))
#C9
val_to_repl <- as.numeric(names(head(sort(table(d$C9),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C9 = val_to_repl))
#C10
val_to_repl <- as.numeric(names(head(sort(table(d$C10),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C10 = val_to_repl))


#C11
val_to_repl <- as.numeric(names(head(sort(table(d$C11),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C11 = val_to_repl))
#C12
val_to_repl <- as.numeric(names(head(sort(table(d$C12),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C12 = val_to_repl))
#C13
val_to_repl <- as.numeric(names(head(sort(table(d$C13),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(C13 = val_to_repl))

#G1
val_to_repl <- as.numeric(names(head(sort(table(d$G1),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(G1 = val_to_repl))
#G2
val_to_repl <- as.numeric(names(head(sort(table(d$G2),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(G2 = val_to_repl))
#G3
val_to_repl <- as.numeric(names(head(sort(table(d$G3),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(G3 = val_to_repl))
#G4
val_to_repl <- as.numeric(names(head(sort(table(d$G4),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(G4 = val_to_repl))
#G5
val_to_repl <- as.numeric(names(head(sort(table(d$G5),decreasing=TRUE),1)))
d_test <- d_test %>% replace_with_na(replace = list(G5 = val_to_repl))

d_test_long <- gather(d_test, "ck_low", "ck_low_value",c(C1:C12))
d_test_long <- gather(d_test_long, "ck_high", "ck_high_value",c(C13:C17))
d_test_long <- gather(d_test_long, "gf", "gf_value",c(G1:G5))


```
### Most common value removed
Plot the distrubution of the measurements of cytokines (C1-C12 and C13-C17) 
```{r Plot with most common value removed ck}
#Histograms of Cytokines, low count values
ggplot(data = d_test_long) +
  geom_histogram(mapping = aes(x = ck_low_value),binwidth = 0.05) +
  facet_wrap( ~ ck_low)

#Histograms of cytokine, high count values
ggplot(data = d_test_long) +
  geom_histogram(mapping = aes(x = ck_high_value),binwidth = 0.05) +
  facet_wrap( ~ ck_high)
```
Plot the distrubution of the measurements of growth factors (G1-G5). The filtering strategy has not been working for this data set. Would have to look further into this. 

```{r Plot with most common value removed gf}
#Histograms of growth factors, low count values
ggplot(data = d_test_long) +
  geom_histogram(mapping = aes(x = gf_value),binwidth = 100) +
  facet_wrap( ~ gf)
```

## Plots of covariation of variables. 
These plots indicate correlation betwwen varialbes. The dot plot cloud is streched out from lower left to upper right. The cloud is not symmetric.
```{r Gather for plots of covariation}
d_long2 <- gather(d, "ck_low", "ck_low_val",c(C2:C13))
d_long2 <- gather(d_long2, "ck_high", "ck_high_val",c(C14:C17))
d_long2 <- gather(d_long2, "gf", "gf_val",c(G3:G5))
```
Plot covariation ck1
```{r Plot covariation ck high count}
ggplot(data = d_long2) +
  geom_point(mapping = aes(x = C1, y = ck_high_val, color = as.factor(Time_point_num))) +#
  facet_wrap( ~  ck_high)
```
```{r Plot covariation ck low count}
ggplot(data = d_long2) +
  geom_point(mapping = aes(x = C1, y = ck_low_val, color = as.factor(Time_point_num))) +
  facet_wrap( ~  ck_low)
```
```{r Plot covariation gfs}
ggplot(data = d_long2) +
  geom_point(mapping = aes(x = G1, y = gf_val, color = as.factor(Time_point_num))) +
  facet_wrap( ~  gf)
```


# Data analysis
The data to be analysed is made up by continuos  variables measured over time and a binary one, and finally binary outcome variable. This limits the number of research question that can be asked. I suggest that the most relevant question involving all variables is weather any of the variables effect the time to outcome? What is needed is a survival analysis. Since the indepent variables are continuos this requires a Cox proportional hazards regression. 

##  Cox proportional hazards regression
For this analyis the coxph function of the "survival" package will be used. It is called as coxph(formula, data, method)
* formula: is linear model with a survival object as the response variable. Survival object is created using the function Surv() as follow: Surv(time, event).
* data: a data frame containing the variables
* method: is used to specify how to handle ties. The default is ‘efron’. Other options are ‘breslow’ and ‘exact’. The default ‘efron’ is generally preferred to the once-popular “breslow” method. The “exact” method is much more computationally intensive.

## Univariate Cox regression with single variable
An initial look at the effect of the sex variable
```{r}
res.cox <- coxph(Surv(Time_point_num, outcome) ~ sex, data = d)
res.cox
summary(res.cox)
```

## Applying the univariate coxph function for each variable
Univariate regression is performed at each variable one by one to single out signficant ones
```{r}
covariates <- names(d)[3:25]
univ_formulas <- sapply(covariates,
                        function(x) as.formula(paste('Surv(Time_point_num, outcome)~', x)))

univ_models <- lapply( univ_formulas, function(x){coxph(x, data = d)})
# Extract data 
univ_results <- lapply(univ_models,
                       function(x){ 
                         x <- summary(x)
                         p.value<-signif(x$wald["pvalue"], digits=2)
                         wald.test<-signif(x$wald["test"], digits=2)
                         beta<-signif(x$coef[1], digits=2);#coeficient beta
                         HR <-signif(x$coef[2], digits=2);#exp(beta)
                         HR.confint.lower <- signif(x$conf.int[,"lower .95"], 2)
                         HR.confint.upper <- signif(x$conf.int[,"upper .95"],2)
                         HR <- paste0(HR, " (", 
                                      HR.confint.lower, "-", HR.confint.upper, ")")
                         res<-c(beta, HR, wald.test, p.value)
                         names(res)<-c("beta", "HR (95% CI for HR)", "wald.test", 
                                       "p.value")
                         return(res)
                         #return(exp(cbind(coef(x),confint(x))))
                       })
res <- t(as.data.frame(univ_results, check.names = FALSE))
```

## Multivariate Cox regression 
Multivariate Cox regression i performed for those variable selected as significant. 
According to this multivariate cox analysis C5, G1 and G2 has significant effect on time to outcome. 
```{r}
res_filt <- res[as.numeric(res[,4]) <= 0.001, ] 
rownames(res_filt)
ind_var <- paste(rownames(res_filt),sep="",collapse=" + ") # havent figure out how to use tis as input
res.cox <- coxph(Surv(time, status) ~ age + sex + ph.ecog, data =  lung)
res.cox <- coxph(Surv(Time_point_num, outcome) ~ C1 + C2 + C3 + C4 + C5 + C7 + C8 + C9 + C12 + C13 + G1 + G2 + G4 , data = d)
res.cox
summary(res.cox)
```
## Verifying the analytic resulst visually
It would be great to be able to display visual proofs/indications that the above performes multivariate cox regression is according to expectations. It would for instance be great if one could crete survival plots for C5 that is found significant an for another variable that is not found significant. That is what I attempt in the following sections. 

### Compute survival curves: survfit()
Below a survival plot data is created for the sex variable
```{r}
fit <- survfit(Surv(Time_point_num, outcome) ~ sex, data = d)
print(fit)
# Summary of survival curves
summary(fit)
# Access to the sort summary table
summary(fit)$table
# Convert list to data frame
data_f <- data.frame(time = fit$time,
                     n.risk = fit$n.risk,
                     n.event = fit$n.event,
                     n.censor = fit$n.censor,
                     surv = fit$surv,
                     upper = fit$upper,
                     lower = fit$lower
)
head(data_f)

```

### Produce the survival curves
Here the survival plot for the sex variable is plotted. The plot indicates that the sex variable makes now diffenece in time to outcome
#```{r}
# Change color, linetype by strata, risk.table color by strata
#ggsurvplot(fit,
#           pval = TRUE, conf.int = TRUE,
#           risk.table = TRUE, # Add risk table
#           risk.table.col = "strata", # Change risk table color by groups
#           linetype = "strata", # Change line type by groups
#           surv.median.line = "hv", # Specify median survival
#           ggtheme = theme_bw(), # Change ggplot2 theme
#           palette = c("#E7B800", "#2E9FDF"))
#```

### From continuous to categorical C5
Here an attempt is made to turn C5 into a categoricla variable so that it can be used for a survivla plot.
A method adapted forbinning skewed distribution would however be needed.

```{r}
#mydata$Agecat2<-cut(mydata$Age, seq(0,30,5))
#https://www.r-bloggers.com/from-continuous-to-categorical/
mi <- min(d$C5, na.rm = TRUE)
ma <- max(d$C5, na.rm = TRUE)
d$C5_cat <- cut(d$C5, seq(mi,ma,1))
min(d$C5)
max(d$C5)

head(d)
fit <- survfit(Surv(Time_point_num, outcome) ~ d$C5_cat, data = d)
print(fit)
# Summary of survival curves
summary(fit)
# Access to the sort summary table
summary(fit)$table
# Convert list to data frame
data_f <- data.frame(time = fit$time,
                     n.risk = fit$n.risk,
                     n.event = fit$n.event,
                     n.censor = fit$n.censor,
                     surv = fit$surv,
                     upper = fit$upper,
                     lower = fit$lower
)
head(data_f)
```

Here the survival plot for the C5 variable is plotted
```{r}
# Change color, linetype by strata, risk.table color by strata
#ggsurvplot(fit,
#           pval = TRUE, conf.int = TRUE,
#          risk.table = TRUE, # Add risk table
#           risk.table.col = "strata", # Change risk table color by groups
#           linetype = "strata", # Change line type by groups
#           surv.median.line = "hv", # Specify median survival
#           ggtheme = theme_bw(), # Change ggplot2 theme
#           palette = c("blue", "red", "green","yellow"))
```

### From continuous to categorical C11
Here an attempt is made to turn C11 into a categoricla variable so that it can be used for a survivla plot.
A method adapted forbinning skewed distribution would however be needed.
```{r}
mi <- min(d$C11, na.rm = TRUE)
ma <- max(d$C11, na.rm = TRUE)
d$C11_cat <- cut(d$C11, seq(mi,ma,0.6))


head(d)
fit <- survfit(Surv(Time_point_num, outcome) ~ d$C11_cat, data = d)
print(fit)
# Summary of survival curves
summary(fit)
# Access to the sort summary table
summary(fit)$table
# Convert list to data frame
data_f <- data.frame(time = fit$time,
                     n.risk = fit$n.risk,
                     n.event = fit$n.event,
                     n.censor = fit$n.censor,
                     surv = fit$surv,
                     upper = fit$upper,
                     lower = fit$lower
)
head(data_f)
```

Here the survival plot for the C11 variable is plotted
```{r}
# Change color, linetype by strata, risk.table color by strata
#ggsurvplot(fit,
#           pval = TRUE, conf.int = TRUE,
#           risk.table = TRUE, # Add risk table
#           risk.table.col = "strata", # Change risk table color by groups
#           linetype = "strata", # Change line type by groups
#           surv.median.line = "hv", # Specify median survival
#           ggtheme = theme_bw(), # Change ggplot2 theme
#           palette = c("blue", "red", "green","yellow"))
```


# Discussion, comments

## Assumption 
I assume in the analysis that the time variable, given as letters in the data, could be replaced by actual numerical time points like weeks since birth. I have replaced a-h with 1-8 for that reason. If the time points should be seen as non ordered categorical data, then another type of analysis would be needed.

## More data munging required
I think many consideration has to be made regarding on to go forward with this data. I am not convinced cox-regressson is the right way to go given that the Time variable is given as letters and not oredered numbers. Should the very frequent values for the cytokines be removed from the analysis? Should values be imputed for the missing values? Should the measurements be normalised against each other?

## Other approaches
1. Alternatives could be binary logistic regression, generalized linear mixed-effects models, weighted generalized estimating equations (https://rdrr.io/cran/wgeesel/man/wgee.html)
2. There are machine learning approaches to this analysis as well.
